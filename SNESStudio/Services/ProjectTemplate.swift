import Foundation

enum ProjectTemplate: String, CaseIterable, Identifiable {
    case basic = "basic"
    case sprite = "sprite"

    var id: String { rawValue }

    var label: String {
        switch self {
        case .basic:  return "Basique"
        case .sprite: return "Sprite Demo"
        }
    }

    var description: String {
        switch self {
        case .basic:  return "Ecran avec couleur de fond, boucle principale"
        case .sprite: return "Sprite anime avec deplacement manette"
        }
    }

    func sourceFiles(config: CartridgeConfig) -> [String: String] {
        var files: [String: String] = [
            "main.asm": generateMain(config: config),
            "header.asm": generateHeader(config: config),
            "init.asm": generateInit(),
        ]

        if config.chip == .sa1 {
            files["sa1.asm"] = generateSA1Init()
        }

        if config.sramSizeKB > 0 {
            files["save.asm"] = generateSaveRoutines(config: config)
        }

        return files
    }

    // MARK: - main.asm

    private func generateMain(config: CartridgeConfig) -> String {
        var code = """
        ; ============================================
        ; \(self == .basic ? "SNES Basic Template" : "SNES Sprite Demo")
        ; Generated by SNES Studio
        ; Cartridge: \(config.mapping.rawValue) \(config.romSizeKB) Ko
        ; ============================================

        .include "header.asm"
        .include "init.asm"

        """

        if config.chip == .sa1 {
            code += ".include \"sa1.asm\"\n"
        }

        if config.sramSizeKB > 0 {
            code += ".include \"save.asm\"\n"
        }

        code += """

        .segment "CODE"

        ; ──────────────────────────────────────────
        ; Reset vector — Entry point
        ; ──────────────────────────────────────────
        .proc Reset
            sei                 ; Disable interrupts
            clc
            xce                 ; Switch to native mode
            rep #$30            ; A/X/Y = 16 bits

            jsr InitSNES        ; Hardware init

        """

        if config.chip == .sa1 {
            code += "    jsr InitSA1         ; Init co-processor\n"
        }

        code += """

            ; Set background color (dark blue)
            sep #$20            ; A = 8 bits
            lda #$80
            sta $2100           ; Force blank ON

            stz $2121           ; CGRAM address = 0
            lda #$00
            sta $2122           ; Color low byte (BGR555)
            lda #$50            ; Dark blue
            sta $2122           ; Color high byte

            lda #$01
            sta $2105           ; BG Mode 1
            lda #$01
            sta $212C           ; Enable BG1 on main screen

            lda #$0F
            sta $2100           ; Force blank OFF, full brightness

        ; ──────────────────────────────────────────
        ; Main Loop
        ; ──────────────────────────────────────────
        MainLoop:
            wai                 ; Wait for VBlank (NMI)
            jsr ReadInput
            jsr UpdateGame
            jmp MainLoop
        .endproc

        ; ──────────────────────────────────────────
        ; NMI (VBlank) Handler
        ; ──────────────────────────────────────────
        .proc NMIHandler
            pha
            phx
            phy

            ; DMA transfers here (tiles, tilemaps, palettes)

            ply
            plx
            pla
            rti
        .endproc

        ; ──────────────────────────────────────────
        ; ReadInput — Read controller
        ; ──────────────────────────────────────────
        .proc ReadInput
            ; Auto-joypad read result in $4218-$4219
            rts
        .endproc

        ; ──────────────────────────────────────────
        ; UpdateGame — Game logic
        ; ──────────────────────────────────────────
        .proc UpdateGame
            rts
        .endproc

        ; ──────────────────────────────────────────
        ; IRQ Handler (unused)
        ; ──────────────────────────────────────────
        .proc IRQHandler
            rti
        .endproc

        """

        return code
    }

    // MARK: - header.asm

    private func generateHeader(config: CartridgeConfig) -> String {
        let mappingByte = String(format: "$%02X", config.mappingHeaderByte)
        let cartTypeByte = String(format: "$%02X", config.cartridgeTypeByte)
        let romSizeByte = String(format: "$%02X", config.romSizeHeaderByte)
        let sramSizeByte = String(format: "$%02X", config.sramSizeHeaderByte)

        return """
        ; ============================================
        ; SNES ROM Header
        ; Generated by SNES Studio
        ; Mapping: \(config.mapping.rawValue), \(config.romSizeKB) Ko ROM
        ; ============================================

        .segment "HEADER"

        ; $FFB0 — Extended header (16 bytes, unused)
        .byte $00, $00, $00, $00, $00, $00, $00, $00
        .byte $00, $00, $00, $00, $00, $00, $00, $00

        ; $FFC0 — Game title (21 bytes, padded with spaces)
        .byte "SNES STUDIO GAME     "

        ; $FFD5 — Map mode
        .byte \(mappingByte)

        ; $FFD6 — Cartridge type
        .byte \(cartTypeByte)

        ; $FFD7 — ROM size (log2(size_in_kb) - 10)
        .byte \(romSizeByte)

        ; $FFD8 — SRAM size
        .byte \(sramSizeByte)

        ; $FFD9 — Destination code (01 = North America)
        .byte $01

        ; $FFDA — Fixed byte
        .byte $33

        ; $FFDB — Version
        .byte $00

        ; $FFDC-$FFDF — Checksum complement / checksum
        .word $FFFF             ; Complement (placeholder)
        .word $0000             ; Checksum (placeholder)

        ; ──────────────────────────────────────────
        ; Native mode vectors ($FFE0-$FFFF)
        ; ──────────────────────────────────────────
        .word $0000             ; $FFE0 — unused
        .word $0000             ; $FFE2 — unused
        .word $0000             ; $FFE4 — COP
        .word $0000             ; $FFE6 — BRK
        .word $0000             ; $FFE8 — ABORT
        .word NMIHandler        ; $FFEA — NMI (VBlank)
        .word $0000             ; $FFEC — unused
        .word IRQHandler        ; $FFEE — IRQ

        ; ──────────────────────────────────────────
        ; Emulation mode vectors ($FFF0-$FFFF)
        ; ──────────────────────────────────────────
        .word $0000             ; $FFF0 — unused
        .word $0000             ; $FFF2 — unused
        .word $0000             ; $FFF4 — COP
        .word $0000             ; $FFF6 — unused
        .word $0000             ; $FFF8 — ABORT
        .word NMIHandler        ; $FFFA — NMI
        .word Reset             ; $FFFC — RESET
        .word IRQHandler        ; $FFFE — IRQ

        """
    }

    // MARK: - init.asm

    private func generateInit() -> String {
        return """
        ; ============================================
        ; SNES Hardware Initialization
        ; Generated by SNES Studio
        ; ============================================

        .segment "CODE"

        ; ──────────────────────────────────────────
        ; InitSNES — Standard hardware init
        ; ──────────────────────────────────────────
        .proc InitSNES
            sep #$20            ; A = 8 bits
            rep #$10            ; X/Y = 16 bits

            ; Force blank
            lda #$80
            sta $2100           ; INIDISP — Force blank ON

            ; Clear PPU registers
            stz $2101           ; OBSEL
            stz $2102           ; OAMADDL
            stz $2103           ; OAMADDH
            stz $2105           ; BGMODE
            stz $2106           ; MOSAIC
            stz $2107           ; BG1SC
            stz $2108           ; BG2SC
            stz $2109           ; BG3SC
            stz $210A           ; BG4SC
            stz $210B           ; BG12NBA
            stz $210C           ; BG34NBA
            stz $210D           ; BG1HOFS
            stz $210D
            stz $210E           ; BG1VOFS
            stz $210E
            stz $210F           ; BG2HOFS
            stz $210F
            stz $2110           ; BG2VOFS
            stz $2110
            stz $2111           ; BG3HOFS
            stz $2111
            stz $2112           ; BG3VOFS
            stz $2112
            stz $2113           ; BG4HOFS
            stz $2113
            stz $2114           ; BG4VOFS
            stz $2114
            stz $2115           ; VMAIN
            stz $2116           ; VMADDL
            stz $2117           ; VMADDH
            stz $2123           ; W12SEL
            stz $2124           ; W34SEL
            stz $2125           ; WOBJSEL
            stz $2126           ; WH0
            stz $2127           ; WH1
            stz $2128           ; WH2
            stz $2129           ; WH3
            stz $212A           ; WBGLOG
            stz $212B           ; WOBJLOG
            stz $212C           ; TM
            stz $212D           ; TS
            stz $212E           ; TMW
            stz $212F           ; TSW
            lda #$30
            sta $2130           ; CGWSEL
            stz $2131           ; CGADSUB
            lda #$E0
            sta $2132           ; COLDATA
            stz $2133           ; SETINI

            ; Clear VRAM
            lda #$80
            sta $2115           ; VMAIN — word access, increment after $2119
            ldx #$0000
            stx $2116           ; VRAM address = $0000
            ldx #$0000
        @clearVRAM:
            stx $2118
            inx
            bne @clearVRAM

            ; Clear CGRAM (all 256 colors to black)
            stz $2121           ; CGRAM address = 0
            ldx #$0100
        @clearCGRAM:
            stz $2122
            stz $2122
            dex
            bne @clearCGRAM

            ; Clear OAM
            stz $2102
            stz $2103
            ldx #$0080
        @clearOAM:
            stz $2104           ; X low
            stz $2104           ; Y (off-screen)
            stz $2104           ; Tile
            stz $2104           ; Attr
            dex
            bne @clearOAM
            ldx #$0020
        @clearOAM2:
            lda #$55            ; All sprites off-screen (high X bit = 1, small size)
            sta $2104
            dex
            bne @clearOAM2

            ; Enable NMI and auto-joypad
            lda #$81
            sta $4200           ; NMITIMEN — NMI on, auto-joypad on

            ; Wait for first VBlank
            lda $4210           ; RDNMI — Clear NMI flag

            cli                 ; Enable interrupts
            rts
        .endproc

        """
    }

    // MARK: - SA-1 init

    private func generateSA1Init() -> String {
        return """
        ; ============================================
        ; SA-1 Co-processor Init
        ; Generated by SNES Studio
        ; ============================================

        .segment "CODE"

        ; ──────────────────────────────────────────
        ; InitSA1 — Initialize SA-1 co-processor
        ; ──────────────────────────────────────────
        .proc InitSA1
            sep #$20
            lda #$00
            sta $2200           ; SA-1 control: reset off

            ; Configure ROM banks for SA-1
            lda #$00
            sta $2220           ; Bank C0-CF = ROM bank 0
            lda #$01
            sta $2221           ; Bank D0-DF = ROM bank 1
            lda #$02
            sta $2222           ; Bank E0-EF = ROM bank 2
            lda #$03
            sta $2223           ; Bank F0-FF = ROM bank 3

            ; Point SA-1 to entry code
            lda #<SA1_Entry
            sta $2209           ; Reset vector low
            lda #>SA1_Entry
            sta $220A           ; Reset vector high

            ; Start SA-1
            lda #$80
            sta $2200           ; SA-1 control: start
            rts
        .endproc

        .segment "SA1CODE"

        ; ──────────────────────────────────────────
        ; SA1_Entry — SA-1 entry point
        ; ──────────────────────────────────────────
        .proc SA1_Entry
        @wait:
            lda $2300           ; SA-1 status
            and #$01            ; Command flag CPU -> SA-1
            beq @wait

            lda $3000           ; Command in shared RAM
            cmp #$01
            beq @done           ; Placeholder

        @done:
            lda #$01
            sta $2201           ; SA-1 -> CPU: done
            bra @wait
        .endproc

        """
    }

    // MARK: - Save routines

    private func generateSaveRoutines(config: CartridgeConfig) -> String {
        let sramAddr: String
        switch config.mapping {
        case .loROM:   sramAddr = "$700000"
        case .hiROM, .exHiROM: sramAddr = "$206000"
        case .sa1:     sramAddr = "$400000"
        }

        return """
        ; ============================================
        ; SRAM Save/Load Routines
        ; Generated by SNES Studio
        ; SRAM: \(config.sramSizeKB) Ko @ \(sramAddr)
        ; ============================================

        .segment "CODE"

        SRAM_BASE = \(sramAddr)
        SRAM_MAGIC_0 = $53     ; 'S'
        SRAM_MAGIC_1 = $41     ; 'A'

        ; ──────────────────────────────────────────
        ; CheckSRAM — Verify SRAM contains valid data
        ; Returns: A = 1 if valid, 0 if empty
        ; ──────────────────────────────────────────
        .proc CheckSRAM
            sep #$20
            lda SRAM_BASE
            cmp #SRAM_MAGIC_0
            bne @empty
            lda SRAM_BASE+1
            cmp #SRAM_MAGIC_1
            bne @empty
            lda #$01
            rts
        @empty:
            lda #$00
            rts
        .endproc

        ; ──────────────────────────────────────────
        ; SaveGame — Write game state to SRAM
        ; ──────────────────────────────────────────
        .proc SaveGame
            sep #$20
            lda #SRAM_MAGIC_0
            sta SRAM_BASE
            lda #SRAM_MAGIC_1
            sta SRAM_BASE+1
            ; TODO: Copy game state to SRAM_BASE+2
            rts
        .endproc

        ; ──────────────────────────────────────────
        ; LoadGame — Read game state from SRAM
        ; ──────────────────────────────────────────
        .proc LoadGame
            jsr CheckSRAM
            cmp #$00
            beq @noSave
            ; TODO: Copy SRAM_BASE+2 to game state
        @noSave:
            rts
        .endproc

        """
    }
}
